<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCD Device Simulator</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
</head>
<body>
    <div class="language-selector">
        <a href="index.html" class="lang-link active">EN</a>
        <span class="lang-sep">|</span>
        <a href="Japanese.html" class="lang-link">日本語</a>
        <span class="lang-sep">|</span>
        <a href="Spanish.html" class="lang-link">Español</a>
    </div>
    <div class="container">
        <div class="device-container">
            <div class="device-image">
                <img src="Device front.png" alt="Device" class="device-bg">
                <div class="power-arrow-indicator"></div>
                <div class="power-button" id="powerButton"></div>
                <div class="lcd-display">
                    <canvas id="lcdCanvas" width="160" height="80"></canvas>
                </div>
                <div class="led-light" id="ledLight"></div>
                <div id="cable" class="cable-container">
                    <svg width="97" height="60" viewBox="0 0 97 60" fill="none" xmlns="http://www.w3.org/2000/svg" class="cable-svg">
                        <path d="M93.129 8.0804V0.695526H26.1489V20.4451H9.7359V23.3847H0.0657604V36.3682H9.7359V38.8179H26.1489V59.1504H93.129V50.8214H95.4755L96.7425 8.0804L93.129 8.0804Z" fill="#979797"/>
                    </svg>
                </div>
            </div>
        </div>
        <div class="side-panel">
            <div class="panel-content">
                <h2>LCD Simulator</h2>
                <div class="flow-selector">
                    <label for="flowSelect">Select Flow:</label>
                    <select id="flowSelect" class="flow-select">
                        
                    </select>
                </div>
                <div class="explanation-box">
                    <h3>Current Step</h3>
                    <p id="stepExplanation">Welcome to the LCD simulator. Use the navigation buttons to explore different states.</p>
                </div>
                <div class="navigation-controls">
                    <button id="prevStep" class="nav-button">Previous</button>
                    <button id="nextStep" class="nav-button">Next</button>
                    <button id="hitShot" class="nav-button shot-button" style="display: none;">Hit Shot</button>
                </div>
                <div class="step-indicator">
                    <span id="currentStep">1</span> / <span id="totalSteps">1</span>
                </div>
                <div class="reference-image-section" id="referenceImageSection" style="display: none;">
                    <h3>Reference Image</h3>
                    <div class="reference-image-container">
                        <img id="referenceImage" src="" alt="Reference screenshot" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Set default language for this page
        window.APP_LANG = 'en';
        (function() {
            const translations = {
                ja: {
                    'Shutting down': 'シャットダウン中',
                    'Searching': '検索中',
                    'Connecting': '接続中',
                    'Connected': '接続完了',
                    'Press and hold': '電源ボタンを長押し',
                    'power button': '',
                    'to shutdown': 'して終了',
                    'Device': 'デバイス',
                    'Powered Off': '電源オフ',
                    'Linking': 'リンク中',
                    'Firmware 1.43': 'ファームウェア 1.43',
                    'Fw 1.43': 'FW 1.43',
                    'Ready': '準備完了',
                    'Remaining:': '残り時間:',
                    'Restarting': '再起動中',
                    'Charger': '充電器',
                    'Disconnected': '切断',
                    'Update Failed': 'アップデート失敗',
                    'Please try again': 'もう一度お試しください',
                    'System Error': 'システムエラー',
                    'Restart Required': '再起動が必要です',
                    'Critical Error': '重大なエラー',
                    'Auto-Restarting...': '自動再起動中...',
                    'Hardware Error': 'ハードウェアエラー',
                    'Contact Support': 'サポートに連絡',
                    'Memory Error': 'メモリエラー',
                    'Sensor Error': 'センサーエラー',
                    'Recalibration Needed': '再キャリブレーションが必要',
                    'Update Complete': 'アップデート完了',
                    'Linking Complete': 'リンク完了'
                },
                es: {
                    'Shutting down': 'Apagando',
                    'Searching': 'Buscando',
                    'Connecting': 'Conectando',
                    'Connected': 'Conectado',
                    'Press and hold': 'Mantén presionado',
                    'power button': 'el botón de encendido',
                    'to shutdown': 'para apagar',
                    'Device': 'Dispositivo',
                    'Powered Off': 'Apagado',
                    'Linking': 'Vinculando',
                    'Firmware 1.43': 'Firmware 1.43',
                    'Fw 1.43': 'Firmware 1.43',
                    'Ready': 'Listo',
                    'Remaining:': 'Restante:',
                    'Restarting': 'Reiniciando',
                    'Charger': 'Cargador',
                    'Disconnected': 'Desconectado',
                    'Update Failed': 'Actualización fallida',
                    'Please try again': 'Inténtalo de nuevo',
                    'System Error': 'Error del sistema',
                    'Restart Required': 'Se requiere reinicio',
                    'Critical Error': 'Error crítico',
                    'Auto-Restarting...': 'Reinicio automático...',
                    'Hardware Error': 'Error de hardware',
                    'Contact Support': 'Contactar soporte',
                    'Memory Error': 'Error de memoria',
                    'Sensor Error': 'Error del sensor',
                    'Recalibration Needed': 'Se requiere recalibración',
                    'Update Complete': 'Actualización completa',
                    'Linking Complete': 'Vinculación completa'
                }
            };
            const lang = (window.APP_LANG || 'en');
            const proto = CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
            if (!proto || proto.__i18nPatched) return;
            function translate(text) {
                if (typeof text !== 'string') return text;
                const map = translations[lang];
                if (!map) return text;
                return Object.prototype.hasOwnProperty.call(map, text) ? map[text] : text;
            }
            const _fillText = proto.fillText;
            const _strokeText = proto.strokeText;
            const groups = {
                shutdownInstruction: [
                    'Press and hold',
                    'power button',
                    'to shutdown'
                ],
                chargerDisconnected: [
                    'Charger',
                    'Disconnected'
                ],
                updateFailed: [
                    'Update Failed',
                    'Please try again'
                ]
            };
            function getGroupIdForText(originalText) {
                for (const key in groups) {
                    if (groups[key].includes(originalText)) return key;
                }
                return null;
            }
            function buildLines(ctx, text, maxWidth, langHint) {
                const fontMatch = (ctx.font || '').match(/(\d+(?:\.\d+)?)px/);
                const lineHeight = (fontMatch ? parseFloat(fontMatch[1]) : 14) * 1.2;
                const lines = [];
                if (!text) return { lines, lineHeight };
                const isCJK = langHint === 'ja' || !/\s/.test(text);
                if (isCJK) {
                    let current = '';
                    for (const ch of text) {
                        const next = current + ch;
                        if (ctx.measureText(next).width <= maxWidth || current.length === 0) {
                            current = next;
                        } else {
                            lines.push(current);
                            current = ch;
                        }
                    }
                    if (current) lines.push(current);
                } else {
                    const words = text.split(/\s+/);
                    let current = '';
                    for (const word of words) {
                        const candidate = current ? current + ' ' + word : word;
                        if (ctx.measureText(candidate).width <= maxWidth || current.length === 0) {
                            current = candidate;
                        } else {
                            lines.push(current);
                            current = word;
                        }
                    }
                    if (current) lines.push(current);
                }
                return { lines, lineHeight };
            }
            function drawWrapped(drawFunc, ctx, text, x, y, targetWidth) {
                const { lines, lineHeight } = buildLines(ctx, text, targetWidth, (window.APP_LANG || 'en'));
                if (lines.length === 0) return;
                for (let i = 0; i < lines.length; i++) {
                    drawFunc.call(ctx, lines[i], x, y + i * lineHeight);
                }
            }
            function fitAndDraw(drawFunc, ctx, text, x, y, maxWidth) {
                const translated = translate(text);
                if (translated === '') return; // allow combined translations to suppress a line
                if (ctx && ctx.__i18nDisableAutoFit) {
                    return drawFunc.call(ctx, translated, x, y);
                }
                const canvasWidth = ctx && ctx.canvas ? ctx.canvas.width : undefined;
                const margin = 8;
                let targetWidth = maxWidth || (canvasWidth ? Math.max(0, canvasWidth - margin * 2) : undefined);
                if (canvasWidth && !maxWidth) {
                    const align = ctx.textAlign || 'left';
                    if (align === 'left') {
                        targetWidth = Math.max(0, canvasWidth - margin - x);
                    } else if (align === 'right') {
                        targetWidth = Math.max(0, x - margin);
                    } else if (align === 'center') {
                        const leftSpace = Math.max(0, x - margin);
                        const rightSpace = Math.max(0, canvasWidth - margin - x);
                        targetWidth = 2 * Math.min(leftSpace, rightSpace);
                    }
                }
                if (!targetWidth) return drawFunc.call(ctx, translated, x, y);
                
                // For Japanese, prioritize font scaling over wrapping to maintain readability
                const originalFont = ctx.font;
                const fontMatch = originalFont.match(/(\d+(?:\.\d+)?)px/);
                if (fontMatch) {
                    const originalSize = parseFloat(fontMatch[1]);
                    const minSize = Math.max(10, originalSize * 0.85); // Minimum 10px or 85% of original
                    
                    // Check if text fits with current font size
                    const textWidth = ctx.measureText(translated).width;
                    if (textWidth > targetWidth) {
                        // Always scale down font size for Japanese to maintain readability
                        const scale = Math.max(minSize / originalSize, targetWidth / textWidth);
                        const newSize = Math.max(minSize, originalSize * scale);
                        ctx.font = originalFont.replace(/\d+(?:\.\d+)?px/, newSize + 'px');
                        drawFunc.call(ctx, translated, x, y);
                        ctx.font = originalFont;
                        return;
                    }
                }
                
                const groupId = getGroupIdForText(text);
                if (groupId) {
                    drawWrapped(drawFunc, ctx, translated, x, y, targetWidth);
                    return;
                }
                drawWrapped(drawFunc, ctx, translated, x, y, targetWidth);
                return;
            }
            proto.fillText = function(text, x, y, maxWidth) {
                return fitAndDraw(_fillText, this, text, x, y, maxWidth);
            };
            proto.strokeText = function(text, x, y, maxWidth) {
                return fitAndDraw(_strokeText, this, text, x, y, maxWidth);
            };
            proto.__i18nPatched = true;
        })();
    </script>
    <script src="script.js"></script>
</body>
</html> 